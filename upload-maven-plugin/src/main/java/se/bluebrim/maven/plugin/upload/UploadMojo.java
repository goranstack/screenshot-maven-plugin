package se.bluebrim.maven.plugin.upload;

import java.awt.geom.AffineTransform;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import javax.imageio.ImageIO;

import org.apache.commons.exec.CommandLine;
import org.apache.commons.exec.DefaultExecutor;
import org.apache.commons.exec.ExecuteException;
import org.apache.commons.httpclient.HttpClient;
import org.apache.commons.httpclient.HttpException;
import org.apache.commons.httpclient.HttpStatus;
import org.apache.commons.httpclient.NameValuePair;
import org.apache.commons.httpclient.methods.PostMethod;
import org.apache.commons.httpclient.methods.multipart.FilePart;
import org.apache.commons.httpclient.methods.multipart.MultipartRequestEntity;
import org.apache.commons.httpclient.methods.multipart.Part;
import org.apache.commons.io.FilenameUtils;
import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.MojoFailureException;
import org.codehaus.plexus.util.DirectoryScanner;


/**
 * Mojo that uploads files from the build directory using HTTP Post method and MultiPartRequestEntity.
 * Tried to configure the wagon plugin to do this task but could'nt get it to work. 
 * <br>
 * The plugin is primarily developed for uploading UML-graphs generated by the UmlGraphDoc Doclet to a tiny
 * CMS. The UML-graphs can then be included in Docbook documentation using absolute URL's. 
 * The plugin scales down UML-graphs that are to large to fit on a Docbook page. 
 * <br>
 * Learned how to handle the includes and excludes parameters from: org.codehaus.mojo.javancss.NcssReportMojo.
 * 
 * @goal upload
 * 
 * @author G Stack
 * 
 */
public class UploadMojo extends AbstractMojo
{

	/**
     * The directory that is scanned for files to upload
     * 
     * @parameter
     * @required
     */
    private File fromDir;
		   

	/**
     * Sub directory path passed as parameter in the upload request.
     * 
     * @parameter
     */
    private String toDir;

	/**
     * The URL that is used in the POST request.
     * 
     * @parameter
     * @required
     */
    private String uploadUrl;


    /**
     * List of ant-style patterns used to specify the files to be uploaded.
     *
     * @parameter
     * @required
     */
    private String[] includes;

    /**
     * List of ant-style patterns used to specify the files that should not be uploaded.
     *
     * @parameter
     */
    private String[] excludes;
    
    /**
     * Maximum image width. If the file to be uploaded contains an image, the image is scaled down if necessary.
     * Typically you want to limit the size of images to be included in pdf documents.
     *
     * @parameter default-value="600" 
     */
	private int maxImageWidth;

	
	public void execute() throws MojoExecutionException, MojoFailureException
	{
		getLog().info("Upload files executed");
		if (!fromDir.exists())
		{
			getLog().info("The \"" + fromDir.getAbsolutePath() + "\" directory is not found");
			return;
		}
		List<File> filesToUpload = getFilesToUpload();
		createSvgFromDot(filesToUpload);
		filesToUpload = getFilesToUpload();
		for (File file : filesToUpload) 
		{			
			FileWrapper fileWrapper = scaleDownToMaxWidth(file);
			try {
				String fileName = file.getName();
				uploadFile(fileName, fileWrapper.file);
			} catch (HttpException e) {
				getLog().error("Unable to upload files: " + file.getAbsolutePath(), e);
			} catch (IOException e) {
				getLog().error("Unable to upload files: " + file.getAbsolutePath(), e);
			}
			fileWrapper.deleteIfTempFile();
		}
	}

	/**
	 * If there is a corresponding .dot file to the specified file, call the Graphviz dot
	 * program to create a SVG file from the .dot file.
	 * For command line invocation of dot see: http://www.graphviz.org/doc/info/command.html and
	 * http://commons.apache.org/exec/tutorial.html
	 * 
	 */
	private void createSvgFromDot(List<File> filesToUpload) 
	{
		for (File file : filesToUpload) 
		{
			File dotFile = new File(file.getParentFile(), FilenameUtils.getBaseName(file.getName()) + ".dot");
			if (dotFile.exists())
			{
				File outputFile = new File(file.getParentFile(), FilenameUtils.getBaseName(file.getName()) + ".svg");
				CommandLine commandLine = CommandLine.parse("dot");
				commandLine.addArgument("-Tsvg");
				commandLine.addArgument("-o");
				commandLine.addArgument(outputFile.getAbsolutePath());
				commandLine.addArgument(dotFile.getAbsolutePath());
				DefaultExecutor executor = new DefaultExecutor();
				try {
					int exitValue = executor.execute(commandLine);
				} catch (ExecuteException e) {
					getLog().error("Unable to execute: \"" + commandLine + "\"", e);
				} catch (IOException e) {
					getLog().error("Unable to execute: \"" + commandLine + "\"", e);
				}				
			}
		}
		
	}

	/**
	 * Did not succeed to append parameters using PostMethod.addParameter().
	 * Found this answer at: http://www.mail-archive.com/httpclient-user@jakarta.apache.org/msg01393.html
	 * <br>
	 * PostMethod.addParameter() and PostMethod.setRequestBody() are mutually
	 * exclusive as they both specify the POST entity and only one can be used
	 * at a time. If you want to send parameters via the URI query string please
	 * use HttpMethod.setQueryString(NameValuePair[])
	 */
	private void uploadFile(String fileName, File file) throws HttpException, IOException
	{
		Part[] parts = {new FilePart(fileName, fileName, file)};
		PostMethod post = new PostMethod(uploadUrl);
		if (toDir != null)
			post.setQueryString(new NameValuePair[]{new NameValuePair("toDir", toDir)});
		post.setRequestEntity(new MultipartRequestEntity(parts, post.getParams()));
		HttpClient client = new HttpClient();
		int status = client.executeMethod(post);
		getLog().debug("HTTP status: " + status + " " + HttpStatus.getStatusText(status));
		getLog().info(post.getResponseBodyAsString());
	}
	
	/**
	 * You should be able to upload any kind of file with this plugin but we
	 * determine the file type by trying to read it as an image. If that fails
	 * we assume that the file is not an image file.
	 */
	private FileWrapper scaleDownToMaxWidth(File file)
	{
//		try {
//			BufferedImage image = ImageIO.read(file);
//			String extension = FilenameUtils.getExtension(file.getName());
//			File tempFile = File.createTempFile(file.getName(), extension);
//			ImageIO.write(scaleDownToMaxWidth(image), extension, tempFile);
//			return new FileWrapper(tempFile, true);
//		} catch (IOException e) {
			return new FileWrapper(file, false);
//		}
	}
	
	private BufferedImage scaleDownToMaxWidth(BufferedImage bufferedImage)
	{
		float scaleFactor = bufferedImage.getWidth() > maxImageWidth ? maxImageWidth / (float) bufferedImage.getWidth() : 1;
		if (scaleFactor < 1)
		{
			AffineTransformOp op = new AffineTransformOp(AffineTransform.getScaleInstance(scaleFactor, scaleFactor), AffineTransformOp.TYPE_BILINEAR); 
			return op.filter(bufferedImage, null);
		} else
			return bufferedImage;
	}


	private List<File> getFilesToUpload() 
	{
		List<File> files = new ArrayList<File>();
        DirectoryScanner ds = new DirectoryScanner();
        ds.setIncludes( includes );
        if ( excludes != null )
            ds.setExcludes( excludes );
        ds.setBasedir( fromDir );
        getLog().debug( "Scanning base directory " + fromDir );
        ds.scan();
        for (String fileName : ds.getIncludedFiles()) {
			files.add(new File(fromDir, fileName));
		}       
        return files;    
	}
	
	private static class FileWrapper
	{
		File file;
		boolean isTempFile;

		public FileWrapper(File file, boolean isTempFile) 
		{
			this.file = file;
			this.isTempFile = isTempFile;
		}
		
		public void deleteIfTempFile()
		{
			if (isTempFile)
				file.delete();
		}
		
		
	}
		
}
